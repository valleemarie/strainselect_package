---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{get-started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(strainselect)
```

<!-- WARNING - This vignette is generated by {fusen} from /dev/flat_full.Rmd: do not edit by hand -->

<!-- Run this 'development' chunk -->

<!-- Store every call to library() that you need to explore your functions -->

# Data examples

```{=html}
```
# prepare_input function

```{=html}
<!--
Include a data table describing bacterial strains according to a number of metadata.
The prepare_input function tests if the strain ID are all different and extracts the metadata selected by the user.
The user can choose to extract the month or the year or both data from the date entered in the initial table.
-->
```
```{r examples-prepare_input}

# Example with your dataset in "inst/"
datafile <- system.file("data_test.csv", package = "strainselect")
raw_data <- read.csv(datafile, sep = ";",header = T)
# Apply my function
prepare_input(raw_data,col_select = c(7,10,13,14,17,24),
              id=1,date=17,m=FALSE,a=TRUE)
```

# assess_gower function

```{=html}
<!--
Include a data table describing bacterial strains according to a number of metadata.
The assess_gower function runs the prepare_input function on the raw data table.
Gower distances are calculated from the dataframe returned by the prepare_input function. The user can choose to apply weights on the metadata he wants to weight. 
A hierarchical cluster analysis is performed using the gower distances and the "complete" method. 
The dendrogram resulting from the hierarchical cluster analysis is plotted if graph=True.
-->
```
```{r examples-assess_gower}
# Example with your dataset in "inst/"
datafile <- system.file("data_test.csv", package = "strainselect")
raw_data <- read.csv(datafile, sep = ";",header = T)
prepared_data <- prepare_input(raw_data,col_select = c(7,10,13,14,17,24),
              id=1,date=17,m=FALSE,a=TRUE)
# Apply my function
assess_gower(prepared_data, graph = T)
```

# cstats_table function

```{=html}
<!--
cstat_table create a dataframe including Cluster stats. The avg.silwidth is the data we are most interest in because it will be used to determine the optimal number of cluster to choose if necessary.
The user enters a distance object and a dendogram object resulting from the function assess_gower. He can choose the number of cluster to test and a step to improve the execution time of the function.
-->
```
```{r examples-cstats_table}
# Example with your dataset in "inst/"
datafile <- system.file("data_test.csv", package = "strainselect")
raw_data <- read.csv(datafile, sep = ";",header = T)
gower <- assess_gower(prepared_data, graph = T)
# Apply my function
cstats_table(dist = gower$gower_dist, tree = gower$aggl.clust.c, k = 50,l = 10)
```

# select_silhouette function

```{=html}
<!--
After setting the number of cluster chosen, the select_silhouette function selects the strain for each cluster that has the maximum silhouette, i.e. the one that is the best clustered.
If there are multiple strains with a maximum silhouette for the same cluster a random selection is made between the strains concerned.

This function return a data frame with for each strain, its characteristics, its cluster, the corresponding cluster size and the strain selected for its cluster.
-->
```
```{r examples-select_silhouette}
datafile <- system.file("data_test.csv", package = "strainselect")
raw_data <- read.csv(datafile, sep = ";",header = T)
gower <- assess_gower(prepared_data, graph = T)
prepared_data <- prepare_input(raw_data,col_select = c(7,10,13,14,17,24),
              id=1,date=17,m=FALSE,a=TRUE)

 select_silhouette(dist=gower$gower_dist,prepared_data = prepared_data, k=50, isdiss = inherits(gower$gower_dist, "dist"),hc_func = "hclust", hc_method = "complete")
```

# prepare_upset function

```{=html}
<!--
The prepare_upset allows to prepare the dataframe used to visualize the interactions. it uses the modalities of the different variables of prepared_data dataframe as columns and fills the rows with 1 if the strain is concerned by the modality and 0 otherwise.
-->
```
```{r examples-prepare_upset}
# Example with your dataset in "inst/"
datafile <- system.file("data_test.csv", package = "strainselect")
raw_data <- read.csv(datafile, sep = ";",header = T)
prepared_data <- prepare_input(raw_data,col_select = c(7,10,13,14,17,24),
              id=1,date=17,m=FALSE,a=TRUE)
# Apply my function
prepare_upset(prepared_data)
```

# define_profile function

```{=html}
<!--
This function uses the output of pepare_upset function to create a new data frame with a column "profiles" resulting  from the concatenation of the columns of the input data frame and a colonne that identify the group of the strain. 
Strain are grouped by identical profiles which allows to consider also the strains with a unique profile.
-->
```
```{r examples-define_profile}
# Example with your dataset in "inst/"
datafile <- system.file("data_test.csv", package = "strainselect")
raw_data <- read.csv(datafile, sep = ";",header = T)
prepared_data <- prepare_input(raw_data,col_select = c(7,10,13,14,17,24),
              id=1,date=17,m=FALSE,a=TRUE)
upset_data <- prepare_upset(prepared_data)
# Apply my function
define_profiles(upset_data)
```

# select_profiles function

```{=html}
<!--
Because the define_profiles function groups strains by identical profile, select_profiles function randomly choose one strain of each group. 
-->
```
```{r examples-select_profile}
# Example with your dataset in "inst/"
datafile <- system.file("data_test.csv", package = "strainselect")
raw_data <- read.csv(datafile, sep = ";",header = T)
prepared_data <- prepare_input(raw_data,col_select = c(7,10,13,14,17,24),
              id=1,date=17,m=FALSE,a=TRUE)
upset_data <- prepare_upset(prepared_data)
upset_profiles <- define_profiles(upset_data)
# Apply my function
select_profiles(upset_profiles,prepared_data)
```

# Inflate your package

You're one inflate from paper to box. Build your package from this very Rmd using `fusen::inflate()`

-   Verify your `"DESCRIPTION"` file has been updated
-   Verify your function is in `"R/"` directory
-   Verify your test is in `"tests/testthat/"` directory
-   Verify this Rmd appears in `"vignettes/"` directory
